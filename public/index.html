<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .node circle {
        cursor: pointer;
        stroke: #3182bd;
        stroke-width: 1.5px;
    }

    .node text {
        font: 10px sans-serif;
        pointer-events: none;
        text-anchor: middle;
    }

    line.link {
        fill: none;
        stroke: #9ecae1;
        stroke-width: 1.5px;
    }
    .avatar {
        border-radius: 20px;
    }
</style>
<body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>

        var width = 1280,
                height = 720,
                root;

        var force = d3.layout.force()
                .linkDistance(80)
                .charge(-200)
                .gravity(.0001)
                .size([width, height])
                .on("tick", tick);

        var svg = d3.select("body")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
        svg.append("defs").attr("id", "defs");

        var link = svg.selectAll(".link"),
                node = svg.selectAll(".node"),
                pattern = d3.select("defs").selectAll(".pattern");
        d3.json("graph.json", function(error, json) {
            root = json;
            update();
        });


        function update() {
            var nodes = flatten(root),
                links = d3.layout.tree().links(nodes);

            // Restart the force layout.
            force
                    .nodes(nodes)
                    .links(links)
                    .start();

            // Update links.
            link = link.data(links, function(d) {
                return d.target.id;
            });

            link.exit().remove();

            link.enter().insert("line", ".node")
                    .attr("class", "link");

            // Update nodes.
            node = node.data(nodes, function(d) {
                //console.log(JSON.stringify(d));
                return d.id;
            });

            node.exit().remove();

            var nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .on("click", click)
                    .call(force.drag);

            nodeEnter.append("circle")
                    .attr("r", function(d) {
                        if (d.class === "avatar") {
                            return 32;
                        }
                        if (d.class === "root") {
                            return 32;
                        }
                        return Math.sqrt(d.size) / 10 || 4.5;

                    }).attr("id", function(d) {
                        return d.name;
            });

            nodeEnter.append("text")
                .attr("dy", ".35em")
                .text(function(d) {
                    return d.name;
                });
           
            pattern = pattern.data(nodes.filter(function(d){return d.class === "avatar";}));
            pattern.exit().remove();

            var patternEnter = pattern.enter()
                .append("pattern")
                .attr("class", "pattern")
                .attr("id", function(d) {
                    if (d.class === "avatar") {
                        return "images-" + d.name;
                    } else {
                        return "";
                    }
                })
                .attr("x", "0")
                .attr("y", "0")
                .attr("patternUnits", "userSpaceOnUse")
                .attr("height", "100")
                .attr("width", "100")
                .append("image")
                .attr("x", "0")
                .attr("y", "0")
                .attr("xlink:href", function(d) {
                    if (d.class === "avatar") {
                        return "images/" + d.name + ".jpeg";
                    } else {
                        return "";
                    }
                });

            node.select("circle").style("fill", function(d) {
                if (d.class === "avatar") {
                    return "url(#images-" + d.name + ")";
                } else {
                    return  color(d);
                }
            });
        }

        function tick() {
            link.attr("x1", function(d) {
                return d.source.x;
            })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });

            node.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
        }

        function color(d) {
            return d._children ? "#3182bd" // collapsed package
                    : d.children ? "#c6dbef" // expanded package
                    : "#fd8d3c"; // leaf node
        }

        // Toggle children on click.
        function click(d) {
            if (d3.event.defaultPrevented)
                return; // ignore drag
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update();
        }

        // Returns a list of all nodes under the root.
        function flatten(root) {
            
            var nodes = [], i = 0;

            function recurse(node) {
                if (node.children)
                    node.children.forEach(recurse);
                if (!node.id)
                    node.id = ++i;
                nodes.push(node);
            }

            recurse(root);
            console.log(JSON.stringify(nodes));
            return nodes;
        }

    </script>
