<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .node circle {
        cursor: pointer;
        stroke: #3182bd;
        stroke-width: 1.5px;
    }

    .node text {
        font: 10px sans-serif;
        pointer-events: none;
        text-anchor: middle;
    }

    line.link {
        fill: none;
        stroke: #9ecae1;
        stroke-width: 1.5px;
    }
</style>
<body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>

        var width = 1280,
                height = 720,
                root;

        var force = d3.layout.force()
                .linkDistance(80)
                .charge(-200)
                .gravity(.0001)
                .size([width, height])
                .on("tick", tick);

        var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);
        /*
         svg.append("defs")
         .append("rect")
         .attr("id", "rect")
         .attr("x", "25%")
         .attr("y", "25%")
         .attr("width", "50%")
         .attr("height", "50%")
         .attr("rx", "45")
         .append("clipPath")
         .attr("id", "clip")
         .append("use")
         .attr("xlink:href", "#rect");
         
         svg.append("use")
         .attr("xlink:href", "#rect")
         .attr("stroke-width", "2")
         .attr("stroke", "white");
         */

        var link = svg.selectAll(".link"),
                node = svg.selectAll(".node");
        defs = svg.append("defs");
        d3.json("graph.json", function(error, json) {
            root = json;
            update();
        });


        function update() {
            var nodes = flatten(root),
                    links = d3.layout.tree().links(nodes);

            // Restart the force layout.
            force
                    .nodes(nodes)
                    .links(links)
                    .start();

            // Update links.
            link = link.data(links, function(d) {
                return d.target.id;
            });

            link.exit().remove();

            link.enter().insert("line", ".node")
                    .attr("class", "link");

            // Update nodes.
            node = node.data(nodes, function(d) {
                //console.log(JSON.stringify(d));
                return d.id;
            });

            node.exit().remove();

            var nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .on("click", click)
                    .call(force.drag);

            nodeEnter.append("circle")
                    .attr("r", function(d) {
                        if (d.class === "avatar") {
                            return 32;
                        }
                        if (d.class === "root") {
                            return 32;
                        }
                        return Math.sqrt(d.size) / 10 || 4.5;

                    }).attr("id", function(d) {
                return d.name;
            });

            nodeEnter.append("text")
                    .attr("dy", ".35em")
                    .text(function(d) {
                        return d.name;
                    });
            nodeEnter.append("svg:image")
                    .attr('x', -24)
                    .attr('y', -24)
                    .attr('width', 48)
                    .attr('height', 48)
                    .attr("xlink:href", function(d) {
                        if (d.class === "avatar") {
                            return "images/" + d.name + ".jpeg";
                        } else {
                            return "";
                        }
                    }).attr("clip-path", "#clip");
                    /*
            defs.append("rect")
                    .attr("id", "rect")
                    .attr("x", "25%")
                    .attr("y", "25%")
                    .attr("width", "50%")
                    .attr("height", "50%")
                    .attr("rx", "45")
                    .append("clipPath")
                    .attr("id", "clip")
                    .append("svg:image")
                    .attr("xlink:href", function(d) {
                        if (d.class === "avatar") {
                            return "images/" + d.name + ".jpeg";
                        } else {
                            return "";
                        }
                    });
                    */
            node.select("circle").style("fill", function(d) {
                if (d.class === "avatar") {
                    return "url(#images-" + d.name + ")";
                } else {
                    return  color(d);
                }
            });
        }

        function tick() {
            link.attr("x1", function(d) {
                return d.source.x;
            })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });

            node.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
        }

        function color(d) {
            return d._children ? "#3182bd" // collapsed package
                    : d.children ? "#c6dbef" // expanded package
                    : "#fd8d3c"; // leaf node
        }

        // Toggle children on click.
        function click(d) {
            if (d3.event.defaultPrevented)
                return; // ignore drag
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update();
        }

        // Returns a list of all nodes under the root.
        function flatten(root) {
            console.log(JSON.stringify(root));
            var nodes = [], i = 0;

            function recurse(node) {
                if (node.children)
                    node.children.forEach(recurse);
                if (!node.id)
                    node.id = ++i;
                nodes.push(node);
            }

            recurse(root);
            return nodes;
        }

    </script>
